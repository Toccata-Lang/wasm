
(add-ns cont (git-dependency "https://github.com/Toccata-Lang/continuation"
                             "continuation.toc"
                             :sha "29c75f0"))

(inline C "
#ifdef TOCCATA_WASM
#include \"emscripten.h\"
#endif\n")

(inline C "

int extractObject(Value *objRef) {
  return((int)((Opaque *)((ReifiedVal *)objRef)->impls[0])->ptr);
}

#ifdef TOCCATA_WASM

EMSCRIPTEN_KEEPALIVE
void decRef(int arg) {
  Value *v = (Value *)arg;
  if (v->refs > 0) {
    dec_and_free(v, 1);
  }
};

void free_JS_obj(void *ptr) {
EM_ASM_({
   objTable[$0] = null;
}, (int) ptr);
// printf(\"freed Obj ref %d\\n\", (int)ptr);
}

EMSCRIPTEN_KEEPALIVE
int mallocStr(int len) {
  return((int)malloc_string(len));
}

EMSCRIPTEN_KEEPALIVE
int strBuffer(int strPtr) {
  if (((Value *)strPtr)->type == StringBufferType) {
    return((int)&((String *)strPtr)->buffer);
  } else if (((Value *)strPtr)->type == SubStringType ||
             ((Value *)strPtr)->type == SymbolType) {
    return((int)((SubString *)strPtr)->buffer);
  } else {
    fprintf(stderr, \"*** Invalid String structure from Javascript\\n\");
    abort();
  }
}

EMSCRIPTEN_KEEPALIVE
int strLength(int strPtr) {
  if (((Value *)strPtr)->type != StringBufferType &&
      ((Value *)strPtr)->type != SubStringType &&
      ((Value *)strPtr)->type != SymbolType) {
    fprintf(stderr, \"*** Invalid String structure from Javascript\\n\");
    abort();
  }
  return((int)((String *)strPtr)->len);
}

EMSCRIPTEN_KEEPALIVE
int mallocOpaque() {
  Value *opaque = opaqueValue(0, free_JS_obj);
  return((int)opaque);
}

EMSCRIPTEN_KEEPALIVE
int opaqueData(int opaquePtr) {
  if (((Value *)opaquePtr)->type != OpaqueType) {
    fprintf(stderr, \"*** Invalid Opaque structure from Javascript\\n\");
    abort();
  }
  return((int)&((Opaque *)opaquePtr)->ptr);
}

EMSCRIPTEN_KEEPALIVE
int mallocMaybe() {
  return((int)malloc_maybe());
}

EMSCRIPTEN_KEEPALIVE
int maybeData(int maybePtr) {
  if (((Value *)maybePtr)->type != MaybeType) {
    fprintf(stderr, \"*** Invalid Maybe structure from Javascript\\n\");
    abort();
  }
  return((int)&((Maybe *)maybePtr)->value);
}

EMSCRIPTEN_KEEPALIVE
int mallocInt() {
  return((int)malloc_integer());
}

EMSCRIPTEN_KEEPALIVE
int intData(int intPtr) {
  if (((Value *)intPtr)->type != IntegerType) {
    fprintf(stderr, \"*** Invalid Integer structure from Javascript\\n\");
    abort();
  }
  return((int)&((Integer *)intPtr)->numVal);
}


EMSCRIPTEN_KEEPALIVE
int mallocVector() {
  return((int)malloc_vector());
}

EMSCRIPTEN_KEEPALIVE
int vectorConj(int vect, int value) {
  Vector *v = mutateVectConj((Vector *)vect, (Value *)value);
  return((int)v);
}

EMSCRIPTEN_KEEPALIVE
int vectCount(Value *v) {
  return(((Vector *)v)->count);
}

EMSCRIPTEN_KEEPALIVE
Value *getVect(Vector *vect, unsigned index) {
  return(vectGet(vect, index));
}

EMSCRIPTEN_KEEPALIVE
int mapVec(int value) {
  Value *v = hashMapVec((Value *)value);
  return((int)v);
}

EMSCRIPTEN_KEEPALIVE
int valueType(Value *v) {
  return(v->type);
}

#endif
")

(defn init []
  (inline C "
#ifdef TOCCATA_WASM
EM_ASM_({
  IntegerType = $0;
  StringBufferType = $1;
  SubStringType = $2;
  MaybeType = $3;
  VectorType = $4;
  SymbolType = $5;
  BitmapIndexedType = $6;
  ArrayNodeType = $7;
  HashCollisionNodeType = $8;

  objTableSize = 1;
  objTable = Array.apply(null, Array(objTableSize));

  objRef = function(x) {
    let i;
    for (i = 1; i < objTableSize; i++) {
      if (objTable[i] == null) {
        objTable[i] = x;
        break;
      }
    }
    if (i == objTableSize) {
      objTable = objTable.concat(Array.apply(null, Array(objTableSize)));
      objTable[objTableSize] = x;
      objTableSize = objTableSize * 2;
    }
    return i;
  };

  objDeref = function(n) {
    if (n < objTableSize)
      return objTable[n];
    else
      return null;
  };

  sendObject = function(x) {
    let intValue = _mallocOpaque();
    let intBuff = _opaqueData(intValue);
    if (x == null)
      setValue(intBuff, 0, \"i64*\");
    else
      setValue(intBuff, objRef(x), \"i64*\");
    return intValue;
  };

  sendInteger = function(x) {
    let intValue = _mallocInt();
    let intBuff = _intData(intValue);
    setValue(intBuff, x, \"i64\");
    return intValue;
  };

  sendString = function(str) {
    let encodedLen = lengthBytesUTF8(str);
    let strValue = _mallocStr(encodedLen);
    let strBuff = _strBuffer(strValue);
    stringToUTF8(str, strBuff, encodedLen + 1);
    return strValue;
  };

  sendRawArray = function(arr) {
    let vect = _mallocVector();
    arr.forEach(function(element) {
      _vectorConj(vect, element);
    });
    return vect;
  };

  sendArray = function(arr) {
    let vect = _mallocVector();
    arr.forEach(function(element) {
      _vectorConj(vect, sendValue(element));
    });
    return vect;
  };

  sendMaybe = function(x) {
    let mv = _mallocMaybe();
    let value = _maybeData(mv);
    if (x == null || x === false)
      setValue(value, 0, \"i64*\");
    else if (x === true)
      setValue(value, sendObject(x), \"i64*\");
    else
      setValue(value, sendValue(x), \"i64*\");
    return mv;
  };

  sendValue = function(v) {
    if (Number.isInteger(v))
      return sendInteger(v);
    else if (typeof v === 'boolean')
      return sendMaybe(v);
    else if (typeof v === 'string')
      return sendString(v);
    else if (Array.isArray(v))
      return sendArray(v);
    else
      return sendObject(v);
  };

  rcvString = function(strValue) {
    var mem = Module['wasmMemory'].buffer;
    const stringBuffer = new Uint8Array(mem, _strBuffer(strValue), _strLength(strValue));
    let str = \"\";
    for (let i = 0; i < stringBuffer.length; i++) {
      str += String.fromCharCode(stringBuffer[i]);
    }
    return str;
  };

  rcvInteger = function(v) {
    let numVal = _intData(v);
    return getValue(numVal, \"i64\");
  };

  rcvMaybe = function(v) {
    let intBuff = _maybeData(v);
    if (getValue(intBuff, \"i64\") == 0)
      return false;
    else
      return true;
  };

  rcvArray = function(v) {
    let arr = new Array(_vectCount(v));
    for (var i = 0; i < _vectCount(v); i++) {
      arr[i] = rcvValue(_getVect(v, i));
    }
    return arr;
  };

  rcvMap = function(v) {
    let m = new Map(rcvArray(_mapVec(v)));
    return m;
  };

  rcvValue = function(v) {
    var valType = _valueType(v);
    if (valType == IntegerType)
      return rcvInteger(v);
    else if (valType == MaybeType)
      return rcvMaybe(v);
    else if (valType == StringBufferType ||
             valType == SubStringType ||
             valType == SymbolType)
      return rcvString(v);
    else if (valType == BitmapIndexedType ||
             valType == ArrayNodeType ||
             valType == HashCollisionNodeType)
      return rcvMap(v);
    else if (valType == VectorType)
      return rcvArray(v);
    else
      throw new Error(\"Cannot send value to Javascript of type: \" + valType);
  }
}, IntegerType, StringBufferType, SubStringType, MaybeType, VectorType, SymbolType,
   BitmapIndexedType, ArrayNodeType, HashCollisionNodeType);
#endif
  return(integerValue(1));
"))

(def _ (init))

(defn JS-eval [s]
  (assert (instance? String s))
  (inline C Opaque  "
#ifdef TOCCATA_WASM
  EM_ASM_({
    eval(rcvString($0));
    }, (int)s_0);
  dec_and_free(s_0, 1);
  return(nothing);
#else
  dec_and_free(s_0, 1);
  return(nothing);
#endif
"))

(defn ptr [x]
  (inline C Integer "
   Value *result = integerValue((int)x_0);
   incRef(result, 1);
   dec_and_free(x_0, 1);
   return(result);
"))

(defn deref [x]
  (inline C  "
   Value *y = (Value *)((Integer *)x_0)->numVal;
   incRef(y, 1);
   dec_and_free(x_0, 1);
   return(y);
"))

(defn callToccata [f args]
  (apply (deref f) (deref args)))

(JS-callable callToccata 2)

(defn set-timeout* [delay f]
  (assert (instance? Integer delay))

  (inline C Maybe "
#ifdef TOCCATA_WASM
  EM_ASM_({
      setTimeout(function(){
             _decRef(callToccata($1, sendRawArray([])))},
         $0);
          },
   (int)((Integer *)delay_0)->numVal, (int)f_1);
#endif
  dec_and_free(delay_0, 1);
  return(nothing);\n"))

(defn async [f]
  (f identity))

(defn wait [delay]
  (cont/Continuation (fn [c]
                  (set-timeout* delay (fn []
                                        (c nothing))))))

(defn handle-event [node key handler]
  (assert (instance? DOMObject node))
  (assert (instance? String key))

  (inline C DOMNode "
#ifdef TOCCATA_WASM
/*
TODO: something like this needs to happen to prevent leaks

if (handler_2->refs > 0){
  fprintf(stderr, \"\\n*** Event handler function must be a global function defined with 'defn'.\\n\");
  abort();
}
*/
  EM_ASM_({
    objDeref($0).addEventListener(rcvString($1),
                 function(){
                  _decRef(callToccata($2, sendArray([])));
                  return false;
                 });
          },
  extractObject(node_0), (int)key_1, (int)handler_2);
#endif
  dec_and_free(key_1, 1);
  return(node_0);\n"))

;; (defn alert* [s]
;;   (assert (instance? String s))
;;   (inline C String "
;;    EM_ASM_({
;;      alert(rcvString($0));},
;;    (int)s_0);
;;    dec_and_free(s_0, 1);
;;    return(nothing);\n"))

;; (defn alert [& xs]
;;   (-> xs
;;       (map str)
;;       (interpose " ")
;;       to-str
;;       alert*))
